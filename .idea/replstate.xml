<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1492387109664">{:repl-history {:ide [], :local [&quot;(some zero? '[1 0 1 1 1])&quot; &quot;(some zero? '[1 1 1 1 1])&quot; &quot;(fnil (some zero? '[1 1 1 1 1]))&quot; &quot;(fnil some zero? '[1 1 1 1 1])&quot; &quot;(defn num-between [num lower upper]\n  (and (&gt;= num lower) (&lt;= num upper)))\n\n(defn order-expressed-as-teens?\n  [num]\n  \&quot;Should we express this number as nineteen or one\n   19 191 919 - should be 19 million, remainder 191 919\n   19 19 191 - should be 1 million, remainder 919 191\n   19 1919 - should be 1 hundred, remainder 91 919\n   19 191 - should be 19 thousand, remainder 191\n   19 19 - should be 1 thousand remainder 919\&quot;\n  (let [teenish [10 10000 10000000]\n        teen      (some #(num-between num % (* 2 %)) teenish)\n        remainder num]\n    [teen remainder]))&quot; &quot;(num-between [10 100 1000])&quot; &quot;(order-expressed-as-teens? 190)&quot; &quot;(order-expressed-as-teens? 19000000)&quot; &quot;(order-expressed-as-teens? 1900000)&quot; &quot;(order-expressed-as-teens? 19000)&quot; &quot;(order-expressed-as-teens? 1900)&quot; &quot;(order-expressed-as-teens? 19)&quot; &quot;(order-expressed-as-teens? 12)&quot; &quot;(order-expressed-from-low-numbers? 12)&quot; &quot;(teen? 1200)&quot; &quot;(teen? 12000)&quot; &quot;(teen? 12)&quot; &quot;(teen? 1900000)&quot; &quot;(if (teen? 19000000)\n  )&quot; &quot;(defn get-teen-with-edges\n  [upper]\n  (let [beyond-teens (* 2 (/ upper 10))\n        twenty (/ upper (/ (/ upper 10) 2))]\n    [beyond-teens twenty]))\n\n&quot; &quot;(mod 12 10)&quot; &quot;(teen? 190000)&quot; &quot;(mod 100 19)&quot; &quot;(quot 100 19)&quot; &quot;(quot 19 100)&quot; &quot;(quot 19 100000)&quot; &quot;(/ 100 19)&quot; &quot;(float (/ 100 19))&quot; &quot;(int (/ 100 19))&quot; &quot;(int (/ 19 100))&quot; &quot;(int (/ 19 100000))&quot; &quot;(int (/ 100000 19))&quot; &quot;(int (mod 100000 19))&quot; &quot;(- 100 19)&quot; &quot;(- 19 100)&quot; &quot;(pos? (- 19 100))&quot; &quot;(- 19231 19000)&quot; &quot;(teen? 1)&quot; &quot;(teen? 19)&quot; &quot;(teen? 19000)&quot; &quot;(/ 19191 10000)&quot; &quot;(int (/ 19191 10000))&quot; &quot;(- 19191 10000)&quot; &quot;(/ 10 (- 19191 10000))&quot; &quot;(int (/ 10 (- 19191 10000)))&quot; &quot;(int (/ (- 19191 10000) 10))&quot; &quot;(- 19191 )&quot; &quot;(/ 100 (- 19191 10000))&quot; &quot;(/ (- 19191 10000) 100)&quot; &quot;(int (/ (- 19191 10000) 100))&quot; &quot;(int (/ (- 20000 19191) 100))&quot; &quot;(- 20000 19191)&quot; &quot;(- 20000 9191)&quot; &quot;(mod 19191 10000)&quot; &quot;(mod 19191 100000)&quot; &quot;(mod 19191 1000)&quot; &quot;(mod 19 10)&quot; &quot;(mod 19 100)&quot; &quot;(mod 19 0)&quot; &quot;(/ 10000 100)&quot; &quot;(/ 10000 10)&quot; &quot;(mod 19191 (/ 10000 10))&quot; &quot;(- 19191 (/ 10000 10))&quot; &quot;(- 19191 191 10000)&quot; &quot;(- 19191 191)&quot; &quot;(/ (- 19191 191) 1000)&quot; &quot;(teen? 19191)&quot; &quot;(teen? 19000000)&quot; &quot;(teen? 19191191)&quot; &quot;(teen? 19000001)&quot; &quot;(defn fact [x]\n  (reduce *' (range 1 (inc x))))&quot; &quot;(fact 10)&quot; &quot;(defn teenables\n  [n]\n  (reduce\n    (fn [a b]\n      (conj a (*' (last a) (last (butlast a)))))\n    [10000 10000000] (range n)))\n&quot; &quot;(teenables 2)&quot; &quot;10000000000&quot; &quot;100000000000&quot; &quot;(defn teenables\n  [n]\n  (reduce\n    (fn [a b]\n      (conj a (*' (last a) 1000)))\n    [10000 10000000] (range n)))\n&quot; &quot;(defn teenables\n  [n]\n  (reduce\n    (fn [a b]\n      (conj a (*' (last a) 1000)))\n    [10000] (range n)))\n&quot; &quot;(teenables 5)&quot; &quot;(defn teenables [n]\n  (reduce (fn [a b]\n      (conj a (*' (last a) 1000)))\n    [10000] (range n)))&quot; &quot;(teenables 1000)&quot; &quot;(defn teenables [n]\n  (take n (reduce (fn [a b]\n                    (conj a (*' (last a) 1000)))\n                  [10000] (range))))&quot; &quot;(teenables 10)&quot; &quot;(def words [:one :two :three :four :five :six :seven :eight :nine :ten\n            :eleven :twelve :thirteen :fourteen :fifteen :sixteen :seventeen :eighteen :nineteen])\n(def singles (zipmap (range 1 20) words))\n; take a random key and get the result\n(get singles (rand-nth (keys singles)))\n\n\n(def x10 [:twenty :thirty :forty :fifty :sixty :seventy :eighty :ninety])\n(def tens (zipmap (range 20 99 10) x10))\n; take a random key and get the result\n(get tens (rand-nth (keys tens)))\n\n\n(defn hundreds\n  [num]\n  (let [hundreds             (quot num 100)\n        carry                (- num (* hundreds 100))\n        zero-carry           (and (zero? carry) [:zero :zero])\n        single-carry         (or zero-carry (get singles carry))\n        single-carry-forward (and single-carry [:zero single-carry])\n        carry                (or zero-carry single-carry (nums-lt-1k carry))]\n    (vec (flatten [(get singles hundreds) carry]))))\n\n(defn nums-lt-1k\n  [num]\n  {:pre [(pos? num)\n         (&lt; num 1000)]}\n  (if (&gt;= num 100)\n    (hundreds num)\n    (if-let [answer (get singles num)]\n      [answer]\n      (let [modulus (mod num 10)\n            tenny   (- num modulus)]\n        (if (zero? modulus)\n          [(get tens tenny)]\n          [(get tens tenny) (get singles modulus)])))))\n&quot; &quot;(defn nums-lt-1k\n  [num]\n  {:pre [(pos? num)\n         (&lt; num 1000)]}\n  (if (&gt;= num 100)\n    (let [hundreds             (quot num 100)\n          carry                (- num (* hundreds 100))\n          zero-carry           (and (zero? carry) [:zero :zero])\n          single-carry         (or zero-carry (get singles carry))\n          single-carry-forward (and single-carry [:zero single-carry])\n          carry                (or zero-carry single-carry (nums-lt-1k carry))]\n      (vec (flatten [(get singles hundreds) carry])))\n    (if-let [answer (get singles num)]\n      [answer]\n      (let [modulus (mod num 10)\n            tenny   (- num modulus)]\n        (if (zero? modulus)\n          [(get tens tenny)]\n          [(get tens tenny) (get singles modulus)])))))&quot; &quot;(nums-lt-1k 1)&quot; &quot;(defn nums-lt-1k\n  [num]\n  {:pre [(pos? num)\n         (&lt; num 1000)]}\n  (if (&gt;= num 100)\n    (let [hundreds             (quot num 100)\n          carry                (- num (* hundreds 100))\n          zero-carry           (and (zero? carry) [:zero :zero])\n          single-carry         (or zero-carry (get singles carry))\n          single-carry-forward (and single-carry [:zero single-carry])\n          carry                (or zero-carry single-carry-forward (nums-lt-1k carry))]\n      (vec (flatten [(get singles hundreds) carry])))\n    (if-let [answer (get singles num)]\n      [answer]\n      (let [modulus (mod num 10)\n            tenny   (- num modulus)]\n        (if (zero? modulus)\n          [(get tens tenny)]\n          [(get tens tenny) (get singles modulus)])))))&quot; &quot;(nums-lt-1k 101)&quot; &quot;(quot 21 10)&quot; &quot;(defn nums-lt-1k\n  [num]\n  {:pre [(pos? num)\n         (&lt; num 1000)]}\n  (if (&gt;= num 100)\n    (let [hundreds       (quot num 100)\n          remaining-tens (- num (* hundreds 100))\n          tens           (quot tens 10)\n          single         (- remaining-tens (* tens 10))\n          hns            (get singles hundreds)\n          tns            (or (get singles tens) :zero)\n          sin            (or (get singles single) :zero)]\n      [hns tns sin])\n    (if-let [answer (get singles num)]\n      [answer]\n      (let [modulus (mod num 10)\n            tenny   (- num modulus)]\n        (if (zero? modulus)\n          [(get tens tenny)]\n          [(get tens tenny) (get singles modulus)])))))&quot; &quot;(* 2 100)&quot; &quot;( - 0) (* 2 100)&quot; &quot;(- 0 (* 2 100))&quot; &quot;(quot 0 10)&quot; &quot;(defn nums-lt-1k\n  [num]\n  {:pre [(pos? num)\n         (&lt; num 1000)]}\n  (if (&gt;= num 100)\n    (let [hundreds       (quot num 100)\n          hns            (get singles hundreds)\n          remaining-tens (- num (* hundreds 100))\n          tens           (quot remaining-tens 10)\n          single         (- remaining-tens (* tens 10))\n          tns            (or (get singles tens) :zero)\n          sin            (or (get singles single) :zero)]\n      [hns tns sin])\n    (if-let [answer (get singles num)]\n      [answer]\n      (let [modulus (mod num 10)\n            tenny   (- num modulus)]\n        (if (zero? modulus)\n          [(get tens tenny)]\n          [(get tens tenny) (get singles modulus)])))))&quot; &quot;(nums-lt-1k 200)&quot; &quot;(nums-lt-1k 201)&quot; &quot;(nums-lt-1k 299)&quot; &quot;(defn- hundreds\n  [num]\n  (let [hundreds       (quot num 100)\n        hundreds-text  (get singles hundreds)\n        remaining-tens (- num (* hundreds 100))\n        tens           (quot remaining-tens 10)\n        single         (- remaining-tens (* tens 10))\n        tens-text      (or (get singles tens) :zero)\n        single-text    (or (get singles single) :zero)]\n    [hundreds-text tens-text single-text]))&quot; &quot;(nums-lt-1k 100)&quot; &quot;(defn nums-lt-1k\n  [num]\n  {:pre [(pos? num) (&lt; num 1000)]}\n  (if (&gt;= num 100)\n    (hundreds num)\n    (if-let [answer (get singles num)]\n      [answer]\n      (let [modulus (mod num 10)\n            tenny   (- num modulus)]\n        (if (zero? modulus)\n          [(get tens tenny)]\n          [(get tens tenny) (get singles modulus)])))))&quot;], :remote []}}</component>
</project>